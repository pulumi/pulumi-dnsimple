// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package dnsimple

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-dnsimple/sdk/v4/go/dnsimple/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Provides a DNSimple zone resource.
//
// > Currently the resource creation acts as an import, so the zone must already exist in DNSimple. The only attribute that will be modified during resource creation is the `active` state of the zone. This is because our API does not allow for the creation of zones. Creation of zones happens through the purchase or creation of domains. We expect this behavior to change in the future.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-dnsimple/sdk/v4/go/dnsimple"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			// Create a zone
//			_, err := dnsimple.NewZone(ctx, "foobar", &dnsimple.ZoneArgs{
//				Name: pulumi.Any(dnsimple.Zone),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// DNSimple zones can be imported using their numeric record ID or the zone name.
//
// bash
//
// ```sh
// $ pulumi import dnsimple:index/zone:Zone resource_name foo.com
// ```
//
// The zone ID can be found within [DNSimple Zones API](https://developer.dnsimple.com/v2/zones/#getZone). Check out [Authentication](https://developer.dnsimple.com/v2/#authentication) in API Overview for available options.
//
// bash
//
// curl -H 'Authorization: Bearer <ACCESS_TOKEN>' https://api.dnsimple.com/v2/1234/zones/example.com | jq
//
// {
//
//	"data": {
//
//	  "id": 1,
//
//	  "account_id": 1234,
//
//	  "name": "example.com",
//
//	  "reverse": false,
//
//	  "secondary": false,
//
//	  "last_transferred_at": null,
//
//	  "active": true,
//
//	  "created_at": "2023-04-18T04:58:01Z",
//
//	  "updated_at": "2024-01-16T15:53:18Z"
//
//	}
//
// }
type Zone struct {
	pulumi.CustomResourceState

	// The account ID for the zone.
	AccountId pulumi.IntOutput `pulumi:"accountId"`
	// Whether the zone is active.
	Active pulumi.BoolOutput `pulumi:"active"`
	// The last time the zone was transferred only applicable for **secondary** zones.
	LastTransferredAt pulumi.StringOutput `pulumi:"lastTransferredAt"`
	// The zone name
	//
	// # Attributes Reference
	Name pulumi.StringOutput `pulumi:"name"`
	// Whether the zone is a reverse zone.
	Reverse pulumi.BoolOutput `pulumi:"reverse"`
	// Whether the zone is a secondary zone.
	Secondary pulumi.BoolOutput `pulumi:"secondary"`
}

// NewZone registers a new resource with the given unique name, arguments, and options.
func NewZone(ctx *pulumi.Context,
	name string, args *ZoneArgs, opts ...pulumi.ResourceOption) (*Zone, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Name == nil {
		return nil, errors.New("invalid value for required argument 'Name'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Zone
	err := ctx.RegisterResource("dnsimple:index/zone:Zone", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetZone gets an existing Zone resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetZone(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *ZoneState, opts ...pulumi.ResourceOption) (*Zone, error) {
	var resource Zone
	err := ctx.ReadResource("dnsimple:index/zone:Zone", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Zone resources.
type zoneState struct {
	// The account ID for the zone.
	AccountId *int `pulumi:"accountId"`
	// Whether the zone is active.
	Active *bool `pulumi:"active"`
	// The last time the zone was transferred only applicable for **secondary** zones.
	LastTransferredAt *string `pulumi:"lastTransferredAt"`
	// The zone name
	//
	// # Attributes Reference
	Name *string `pulumi:"name"`
	// Whether the zone is a reverse zone.
	Reverse *bool `pulumi:"reverse"`
	// Whether the zone is a secondary zone.
	Secondary *bool `pulumi:"secondary"`
}

type ZoneState struct {
	// The account ID for the zone.
	AccountId pulumi.IntPtrInput
	// Whether the zone is active.
	Active pulumi.BoolPtrInput
	// The last time the zone was transferred only applicable for **secondary** zones.
	LastTransferredAt pulumi.StringPtrInput
	// The zone name
	//
	// # Attributes Reference
	Name pulumi.StringPtrInput
	// Whether the zone is a reverse zone.
	Reverse pulumi.BoolPtrInput
	// Whether the zone is a secondary zone.
	Secondary pulumi.BoolPtrInput
}

func (ZoneState) ElementType() reflect.Type {
	return reflect.TypeOf((*zoneState)(nil)).Elem()
}

type zoneArgs struct {
	// Whether the zone is active.
	Active *bool `pulumi:"active"`
	// The zone name
	//
	// # Attributes Reference
	Name string `pulumi:"name"`
}

// The set of arguments for constructing a Zone resource.
type ZoneArgs struct {
	// Whether the zone is active.
	Active pulumi.BoolPtrInput
	// The zone name
	//
	// # Attributes Reference
	Name pulumi.StringInput
}

func (ZoneArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*zoneArgs)(nil)).Elem()
}

type ZoneInput interface {
	pulumi.Input

	ToZoneOutput() ZoneOutput
	ToZoneOutputWithContext(ctx context.Context) ZoneOutput
}

func (*Zone) ElementType() reflect.Type {
	return reflect.TypeOf((**Zone)(nil)).Elem()
}

func (i *Zone) ToZoneOutput() ZoneOutput {
	return i.ToZoneOutputWithContext(context.Background())
}

func (i *Zone) ToZoneOutputWithContext(ctx context.Context) ZoneOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ZoneOutput)
}

// ZoneArrayInput is an input type that accepts ZoneArray and ZoneArrayOutput values.
// You can construct a concrete instance of `ZoneArrayInput` via:
//
//	ZoneArray{ ZoneArgs{...} }
type ZoneArrayInput interface {
	pulumi.Input

	ToZoneArrayOutput() ZoneArrayOutput
	ToZoneArrayOutputWithContext(context.Context) ZoneArrayOutput
}

type ZoneArray []ZoneInput

func (ZoneArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Zone)(nil)).Elem()
}

func (i ZoneArray) ToZoneArrayOutput() ZoneArrayOutput {
	return i.ToZoneArrayOutputWithContext(context.Background())
}

func (i ZoneArray) ToZoneArrayOutputWithContext(ctx context.Context) ZoneArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ZoneArrayOutput)
}

// ZoneMapInput is an input type that accepts ZoneMap and ZoneMapOutput values.
// You can construct a concrete instance of `ZoneMapInput` via:
//
//	ZoneMap{ "key": ZoneArgs{...} }
type ZoneMapInput interface {
	pulumi.Input

	ToZoneMapOutput() ZoneMapOutput
	ToZoneMapOutputWithContext(context.Context) ZoneMapOutput
}

type ZoneMap map[string]ZoneInput

func (ZoneMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Zone)(nil)).Elem()
}

func (i ZoneMap) ToZoneMapOutput() ZoneMapOutput {
	return i.ToZoneMapOutputWithContext(context.Background())
}

func (i ZoneMap) ToZoneMapOutputWithContext(ctx context.Context) ZoneMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ZoneMapOutput)
}

type ZoneOutput struct{ *pulumi.OutputState }

func (ZoneOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Zone)(nil)).Elem()
}

func (o ZoneOutput) ToZoneOutput() ZoneOutput {
	return o
}

func (o ZoneOutput) ToZoneOutputWithContext(ctx context.Context) ZoneOutput {
	return o
}

// The account ID for the zone.
func (o ZoneOutput) AccountId() pulumi.IntOutput {
	return o.ApplyT(func(v *Zone) pulumi.IntOutput { return v.AccountId }).(pulumi.IntOutput)
}

// Whether the zone is active.
func (o ZoneOutput) Active() pulumi.BoolOutput {
	return o.ApplyT(func(v *Zone) pulumi.BoolOutput { return v.Active }).(pulumi.BoolOutput)
}

// The last time the zone was transferred only applicable for **secondary** zones.
func (o ZoneOutput) LastTransferredAt() pulumi.StringOutput {
	return o.ApplyT(func(v *Zone) pulumi.StringOutput { return v.LastTransferredAt }).(pulumi.StringOutput)
}

// The zone name
//
// # Attributes Reference
func (o ZoneOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *Zone) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// Whether the zone is a reverse zone.
func (o ZoneOutput) Reverse() pulumi.BoolOutput {
	return o.ApplyT(func(v *Zone) pulumi.BoolOutput { return v.Reverse }).(pulumi.BoolOutput)
}

// Whether the zone is a secondary zone.
func (o ZoneOutput) Secondary() pulumi.BoolOutput {
	return o.ApplyT(func(v *Zone) pulumi.BoolOutput { return v.Secondary }).(pulumi.BoolOutput)
}

type ZoneArrayOutput struct{ *pulumi.OutputState }

func (ZoneArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Zone)(nil)).Elem()
}

func (o ZoneArrayOutput) ToZoneArrayOutput() ZoneArrayOutput {
	return o
}

func (o ZoneArrayOutput) ToZoneArrayOutputWithContext(ctx context.Context) ZoneArrayOutput {
	return o
}

func (o ZoneArrayOutput) Index(i pulumi.IntInput) ZoneOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Zone {
		return vs[0].([]*Zone)[vs[1].(int)]
	}).(ZoneOutput)
}

type ZoneMapOutput struct{ *pulumi.OutputState }

func (ZoneMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Zone)(nil)).Elem()
}

func (o ZoneMapOutput) ToZoneMapOutput() ZoneMapOutput {
	return o
}

func (o ZoneMapOutput) ToZoneMapOutputWithContext(ctx context.Context) ZoneMapOutput {
	return o
}

func (o ZoneMapOutput) MapIndex(k pulumi.StringInput) ZoneOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Zone {
		return vs[0].(map[string]*Zone)[vs[1].(string)]
	}).(ZoneOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ZoneInput)(nil)).Elem(), &Zone{})
	pulumi.RegisterInputType(reflect.TypeOf((*ZoneArrayInput)(nil)).Elem(), ZoneArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ZoneMapInput)(nil)).Elem(), ZoneMap{})
	pulumi.RegisterOutputType(ZoneOutput{})
	pulumi.RegisterOutputType(ZoneArrayOutput{})
	pulumi.RegisterOutputType(ZoneMapOutput{})
}
